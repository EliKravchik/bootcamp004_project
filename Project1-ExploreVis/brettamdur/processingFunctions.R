library(ggplot2)
library(dplyr)
library(reshape2)

perfectValues <- function(limitno){
# Creates perfect (1 or 0) y values for each head to head matchup.
# Returns a list of vectors, one vector for each ranking up to limitno
	pLineList <- list()
	for(i in 1:limitno){
		pvect <- as.integer(vector())
		for(j in 1:limitno){
			ifelse(i == j, pvect[j] <- NA, 
			       ifelse(i < j, pvect[j] <- 1, 
			              pvect[j] <- 0))
		}
		pLineList[[i]] <- pvect
	}
	return(pLineList)
}

perfectReg <- function(pValues){
# takes a list of perfect value vectors created by perfectValues(), and returns a list
# of regression models, one for each vector
	pRegList <- list()
	for(i in 1:length(pValues)){
		pReg <- NULL 	# each element in pRegList will be a regression model fit (called pReg)
				# to a set of perfect values.
		#perfHold <- cbind(pValues[[i]], 1:length(pValues))
		perfHold <- data.frame(x = 1:length(pValues), y = pValues[[i]])
		fit <- lm(y ~ x, data = perfHold)
		pRegList[[i]] <- fit
	}
	return(pRegList)
}

makePredictions <- function(perfModels, perfActual, plotStartRank, plotStopRank){
# takes in list of perfect models generated by perfectReg, and returns
# four dataframes: 1) y_perfect (the actual value the model 
# predicts), 2) y_hat (the adjusted y value that puts all y values between 0 and 1)
# 3) the actuals (just returning what was sent in, w/out modification), and 4) the residuals.
# Each data frame is of dimension n x n, where n is limitno.
	
	#### y_perfect ####
	predictGrid <- data.frame()
	newdf <- data.frame(x = c(plotStartRank:plotStopRank)) # the x values to use in prediction model
	for(i in plotStartRank:plotStopRank){
		predictGrid <- rbind(predictGrid, predict(perfModels[[i]], newdf))
	}
	names(predictGrid) <- as.character(c(plotStartRank:plotStopRank))
	predictGrid$rank <- c(plotStartRank:plotStopRank) # add a column for player rank
	predictGrid <- predictGrid[, c(ncol(predictGrid), 1:ncol(predictGrid)-1)] # move the player rank column to beginning

	#### y_hat ####
	y_hatGrid <- predictGrid
	y_hatGrid[y_hatGrid < 0] <- 0
	y_hatGrid[y_hatGrid > 1] <- 1
	y_hatGrid <- y_hatGrid[, -1] # get rid of the rank column, which we just made inaccurate with the 0/1 replacement
	y_hatGrid$rank <- c(1:length(y_hatGrid)) # add a column for player rank
	y_hatGrid <- y_hatGrid[, c(ncol(y_hatGrid), 1:ncol(y_hatGrid)-1)] # move the player rank column to beginning
	
	### residuals ####
	actValues <- perfActual[[1]]
	resids <- apply(actValues, 2, FUN = function(x) as.numeric(x)) - as.matrix(y_hatGrid[, -1]) #it's ugly, but it works
	resids <- as.data.frame(data.matrix(resids)) # convert it to df with numerical columns
	resids$rank <- c(1:length(resids)) # add a column for player rank
	resids <- resids[, c(ncol(resids), 1:ncol(resids)-1)] # move the player rank column to beginning
	
	### MSE ###
	mse <- apply(resids, 1, function(x) sum(x^2, na.rm = TRUE))
	mse <- mse / length(mse)
	mse <- mean(mse, na.rm = TRUE)
	
	### actual values ####
	actValuesGrid <- as.data.frame(data.matrix(actValues)) # convert it to df with numerical columns
	actValuesGrid$rank <- c(1:length(actValuesGrid)) # add a column for player rank
	actValuesGrid <- actValuesGrid[, c(ncol(actValuesGrid), 1:ncol(actValuesGrid)-1)] # move the player rank column to beginning
	
	return(list(predictGrid = predictGrid, y_hatGrid = y_hatGrid, actValuesGrid = actValuesGrid, residsGrid = resids, mse = mse))
}

# plot one of the four grids created by makePredictions
plotGrid <- function(grid){
	meltedValuesdf <- melt(grid, id = "rank")	
	cc <- scales::seq_gradient_pal("yellow", "black", "Lab")(seq(0,1,length.out=length(unique(meltedValuesdf$variable))))
	# note that aes call has the x,y, and group as it does to plot the rows of the grid, rather than
	# the columns.
	myPlot <- ggplot(meltedValuesdf, aes(x=variable, y = value, color = as.factor(rank))) + 
			geom_point(size = 10, alpha = .6) + 
			# geom_line(aes(group = as.factor(rank))) + 
			scale_colour_manual(values = cc) +
			# scale_x_discrete() + scale_y_continuous(limits = c(0,1)) +
			theme_classic()
	return(myPlot)
}


# # valuesdfTopHalf <- valuesdf[ , c(1, 52:101)]
# meltedValuesdfTopHalf <- melt(valuesdfTopHalf, id = "x")

# cc <- scales::seq_gradient_pal("yellow", "black", "Lab")(seq(0,1,length.out=length(hold)))
# ggplot(meltedValuesdf, aes(x = x, y = value, color=variable)) + 
# 	geom_smooth(method = lm, se = FALSE) +
# 	# scale_color_brewer() +
# 	# scale_color_discrete() +
# 	scale_colour_manual(values = cc)
# 	geom_hline(yintercept = c(0,1)) +
# 	theme_classic()
# 
# 
# cc <- scales::seq_gradient_pal("light blue", "dark blue", "Lab")(seq(0,1,length.out=10))
# ggplot(testmelted, aes(x=rank, y = value, color = variable)) + 
# 	geom_point(size = 6) + geom_line() + 
# 	scale_colour_manual(values = cc)

###
